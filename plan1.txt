Apollo 的规划模块采用了一种先进的、基于场景（Scenario）的软件架构。该框架的核心是场景管理器（ScenarioManager），它如同一个交通指挥中心，根据车辆的当前位置、高精地图信息、感知结果以及路由请求，动态地决策并调度最合适的驾驶场景。这种模块化的设计，使得 Apollo 能够将复杂的驾驶任务分解为一系列独立的、可管理的场景，例如车道保持（Lane Follow）、靠边停车（Pull Over）以及我们本次关注的无保护路口停止（Stop Sign Unprotected）等 。   

在默认的开放道路规划器 PublicRoadPlanner 中，ScenarioManager 扮演着至关重要的角色 。当车辆接近一个有停止标志的路口时，   

ScenarioManager 会识别出这一特定情境，并将车辆的控制权从常规的“车道保持”场景切换到专门处理该任务的 StopSignUnprotectedScenario 场景。理解这一顶层设计是后续进行针对性代码修改的基础，因为它明确了我们的工作将主要聚焦于 StopSignUnprotectedScenario 及其相关的交通规则模块。

1.1 交通规则层：停车决策的起源 (Traffic Rule Layer)
在 Apollo 的规划流程中，最先对停止标志做出反应的并非复杂的场景状态机，而是一个更为基础和通用的模块——交通规则层。具体而言，modules/planning/traffic_rules/stop_sign/stop_sign.cc 文件定义了处理停止标志的基本规则 。   

此规则在每个规划周期的早期阶段被 TrafficDecider 调用。它的核心功能是检查高精地图数据，识别出参考线上是否存在停止标志的重叠区（Stop Sign Overlap）。一旦发现，其 ApplyRule 函数会调用一个通用辅助函数 util::BuildStopDecision（位于 modules/planning/planning_base/common/util/common.cc）。这个函数通过在地图上定义的停止线前，创建一个固定距离的“虚拟停止墙”（Virtual Stop Wall）障碍物，从而在规划层面生成一个强制性的停车指令。这个虚拟障碍物对于后续的速度规划器来说，是一个不可逾越的硬性约束，从而确保车辆会执行停车动作。   

控制这个虚拟墙与停止线之间距离的关键，是 modules/planning/traffic_rules/stop_sign/conf/default_conf.pb.txt 配置文件中的 stop_distance 参数 。该参数的定义可以在对应的    

proto 文件 modules/planning/traffic_rules/stop_sign/proto/stop_sign.proto 中找到 。   

这种设计体现了 Apollo 架构中一个重要的解耦思想：决策的触发与行为的执行相分离。StopSign 交通规则仅负责在宏观层面下达“此处必须停车”的指令，它不关心车辆如何停、停多久、以及何时再次启动。而这些复杂的、带有状态记忆的行为，则交由更高层次的场景层（Scenario Layer）来具体实现。这一架构的清晰划分，使得我们可以将竞赛任务精确地分解为两个独立的子问题：在交通规则层调整停车的位置，在场景层重构停车的行为。

1.2 场景层：停车行为的状态机 (Scenario Layer)
当 ScenarioManager 将控制权交给 StopSignUnprotectedScenario 后，车辆的行为便由一个精细定义的状态机来管理。这个状态机的流程和任务配置在 modules/planning/scenarios/stop_sign_unprotected/conf/pipeline.pb.txt 文件中定义 。它将整个通过停止路口的过程分解为四个核心阶段（Stage）：   

PRE_STOP 阶段: 由 stage_pre_stop.cc 实现 。此阶段负责在车辆接近停止线时，平稳地减速。同时，它会开始观察交叉口的其他交通参与者，特别是其他车道上的车辆，并将它们添加到一个名为    

watch_vehicles 的内部列表中，为下一阶段的决策做准备。

STOP 阶段: 由 stage_stop.cc 实现 。这是执行停车等待的核心阶段。通过深入分析其    

Process 函数的源代码，可以发现其核心等待逻辑是基于一个简单的计时器。代码中明确检查当前等待时间 wait_time 是否小于配置文件 scenario_conf.pb.txt 中定义的 stop_duration_sec 。只要等待时间不足，车辆就会保持停止状态。   

CREEP 阶段: 由 stage_creep.cc 实现 。在固定的等待时间结束后，如果系统认为有必要（例如，视野受阻），车辆会进入此阶段。它会以一个非常低的速度（即“蠕行”）缓慢向前移动一小段距离，目的是为了越过可能的视野遮挡物（如停在路边的车辆或建筑物），从而获得一个更清晰、更安全的交叉口观测视角。   

INTERSECTION_CRUISE 阶段: 在确认路口安全后，车辆进入此阶段，加速并正常通过交叉口。

对该状态机的分析揭示了当前 Apollo 实现在应对 ISCC 2025 竞赛要求时的核心不足：STOP 阶段的安全逻辑过于简单。它依赖于一个固定的、与环境无关的计时器，而不是一个能够实时感知和预测交叉口动态环境的智能决策系统。竞赛要求车辆必须在确认“清场/安全”后才能通行，而当前的“计时等待”机制显然无法满足这一高级别的安全要求。因此，对 stage_stop.cc 的逻辑进行彻底重构，将是本次解决方案的核心技术挑战。

第二章：解决方案实施策略与代码修改
2.1 任务一：实现厘米级精准停车 (2.0-2.5米)
2.1.1 问题分析与关键补偿
要实现车头在停止线前 2.0–2.5 米的精准停车，仅仅修改 stop_distance 参数是不够的，还需要对车辆的物理尺寸进行精确补偿。

Apollo 规划模块中的所有计算都是基于车辆的规划参考点，该点通常位于车辆的后轴中心。然而，stop_distance 参数定义的距离是这个规划参考点到停止线的距离。竞赛规则衡量的则是车辆最前端，即前保险杠，到停止线的距离。

因此，若忽略车辆从后轴中心到车头的这段物理长度，会导致车辆实际停车位置比预期过于靠前，极有可能超出 2.0 米的下限，甚至越过停止线，直接导致任务失败。为了解决这个问题，必须在配置文件中对 stop_distance 进行补偿。正确的计算公式为：

stop_distance 
config
​
 =distance 
bumper_to_stopline
​
 +front_edge_to_center

其中，distance 
bumper_to_stopline
​
  是竞赛要求的车头目标停车距离（我们选择中间值 2.25 米），而 front_edge_to_center 是车辆的固有参数，表示从车辆后轴中心到车头保险杠的距离。该值可以在 Apollo 的车辆配置文件（modules/common/data/vehicle_param.pb.txt）中查到。

2.1.2 配置文件修改
根据上述分析，我们需要对两个文件进行修改。

修改 stop_sign.proto 文件：为了代码的可读性和长期维护性，建议在参数定义处添加详细注释，明确其物理意义。

文件路径: modules/planning/traffic_rules/stop_sign/proto/stop_sign.proto

修改内容: 为 stop_distance 字段添加注释。

修改 default_conf.pb.txt 文件：应用上述公式，计算并设置新的 stop_distance 值。

文件路径: modules/planning/traffic_rules/stop_sign/conf/default_conf.pb.txt

修改步骤:
a.  从车辆配置文件中查得 front_edge_to_center 的值。以 Apollo 官方提供的 Lincoln MKZ 车型为例，该值约为 3.89 米。
b.  选择竞赛要求的停车距离中值，即 2.25 米。
c.  计算配置值：2.25+3.89=6.14 米。

修改内容: 将 stop_distance 的值更新为计算结果。

2.2 任务二：构建智能“清场等待”决策脑 (Wait-for-Clear Logic)
2.2.1 算法设计
为了实现智能、安全的等待逻辑，需要彻底替换 stage_stop.cc 中基于时间的决策机制。新的核心策略是实现一个名为 IsIntersectionClear() 的布尔函数，该函数将在 STOP 阶段的每个规划周期被调用，实时评估交叉口的通行风险。

IsIntersectionClear() 算法流程:

定义主车冲突区域 (Define Ego's Conflict Zone):

从 reference_line_info 中获取当前规划出的、用于通过路口的路径 path_data。

遍历该路径上的所有路径点。在每个路径点处，根据车辆的宽度参数（vehicle_param().width()）向两侧进行扩展，形成一系列连续的矩形。

将这些矩形合并，最终形成一个能够完整覆盖主车未来行驶轨迹的几何多边形（Polygon）。这个多边形就是进行时空碰撞检测的“空间”区域。

获取所有动态障碍物:

从当前的规划帧 frame 中，获取 path_decision 内的所有障碍物。

筛选出所有动态障碍物，即类型为 VEHICLE, PEDESTRIAN, BICYCLE 的障碍物。静态障碍物（如路锥、石头）在此阶段不予考虑。

时空碰撞检查 (Spatio-Temporal Collision Check):

遍历所有筛选出的动态障碍物。

对于每一个障碍物，获取其最可能的一条预测轨迹 obstacle->Trajectory()。预测模块会为每个障碍物生成一条或多条带概率的轨迹，这里我们选择概率最高的一条。

检查该预测轨迹在未来的一段时间内（例如，5秒）的每一个时间点。在每个时间点 t，获取障碍物的预测位置包围盒（Predicted Bounding Box）。

判断在时间点 t 的这个预测包围盒，是否与步骤 1 中定义的主车冲突区域多边形发生重叠（Intersection/Overlap）。

最终决策:

如果在检查过程中，任何一个动态障碍物的预测轨迹与主车冲突区域发生了重叠，则立即认定路口不安全，IsIntersectionClear() 函数返回 false。

只有当所有动态障碍物的预测轨迹在未来时间段内都与主车冲突区域完全没有重叠时，才能认定路口是“清场”的，函数返回 true。

2.2.2 C++ 代码实现
对 modules/planning/scenarios/stop_sign_unprotected/stage_stop.cc 文件进行重构。

在 StopSignUnprotectedStageStop::Process 函数中，完全移除原有代码中对 wait_time 和 stop_duration_sec 的判断逻辑。

在 Process 函数的主循环中，转而调用新实现的 IsIntersectionClear(frame, reference_line_info) 函数。

根据 IsIntersectionClear 的返回值进行决策：

如果返回 true，表示路口安全，可以通行。此时调用 FinishStage()，将状态机切换到下一阶段（通常是 CREEP 或 INTERSECTION_CRUISE）。

如果返回 false，表示路口仍然存在风险，必须继续等待。此时，函数应返回 result.SetStageStatus(StageStatusType::RUNNING)，以保持在当前的 STOP 阶段，并确保停车的虚拟墙决策继续生效。

2.2.3 效果对比
为了更清晰地展示该方案带来的提升，下表对比了原始 Apollo 逻辑与本次竞赛方案逻辑的核心差异：

特性	原始 Apollo 逻辑	竞赛方案逻辑
停车条件	等待固定的 stop_duration_sec 秒。	持续等待，直到交叉路口在预测时间内无冲突目标。
障碍物评估	监控在 PRE_STOP 阶段识别的 watch_vehicles 列表。	动态评估当前帧感知到的所有动态障碍物（车辆、行人等）及其预测轨迹。
安全检查	基于时间。	基于时空预测，主动检查在预定义的冲突区域内是否存在潜在碰撞。
阶段切换	计时器到期后切换到下一阶段。	仅在冲突区域被验证为“清场”后才切换，确保更高的安全性和态势感知能力。
